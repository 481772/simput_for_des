!function(e){function n(t){if(l[t])return l[t].exports;var a=l[t]={exports:{},id:t,loaded:!1};return e[t].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}var l={};return n.m=e,n.c=l,n.p="",n(0)}([function(e,n,l){(function(n){n.Simput||(n.Simput={}),n.Simput.types||(n.Simput.types={}),e.exports=n.Simput.types["openfoam-windtunnel"]=l(1)}).call(n,function(){return this}())},function(e,n,l){"use strict";e.exports={type:"openfoam-windtunnel",model:l(2),lang:l(3),convert:l(9),parse:null}},function(e,n){e.exports={order:["InitialConditions","WindTunnel","Parameters"],views:{InitialConditions:{attributes:["initconst","initfields","transport"]},WindTunnel:{attributes:["wallBounds","wallAssign"]},Parameters:{attributes:["controldict-time","controldict-write"]},Solvers:{attributes:["solver-p","solver-U","solver-k","solver-omega","correctors","relaxationFactors"]},Decomposition:{attributes:["decomposeParDict","decomposition_simpleCoeffs","decomposition_hierarchicalCoeffs","forceCoeffs"]},Mesh:{attributes:["meshQuality","meshRefinement"]},Runtime:{attributes:["runtime"],size:-1}},external:{meshName:"motorBike",meshBounds:[-.292,1.75,-.35,.332,-423e-7,1.35]},definitions:{initconst:{label:"Constants",parameters:[{label:"Flow velocity",id:"initialConditions.flowVelocity",type:"double",size:3,"default":[20,0,0]},{label:"Pressure",id:"initialConditions.pressure",type:"double",size:1,"default":[0]},{label:"Turbulent KE",id:"initialConditions.turbulentKE",type:"double",size:1,"default":[.24]},{label:"Turbulent Omega",id:"initialConditions.turbulentOmega",type:"double",size:1,"default":[1.78]}]},initfields:{label:"Fields initialisation",parameters:[{label:"Dimensions for k",id:"fields.k.dimensions",type:"double",size:7,"default":[0,2,-2,0,0,0,0]},{label:"Dimensions for nut",id:"fields.nut.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Dimensions for omega",id:"fields.omega.dimensions",type:"double",size:7,"default":[0,0,-1,0,0,0,0]},{label:"Dimensions for p",id:"fields.p.dimensions",type:"double",size:7,"default":[0,2,-2,0,0,0,0]},{label:"Dimensions for U",id:"fields.U.dimensions",type:"double",size:7,"default":[0,1,-1,0,0,0,0]},{label:"Inlet value for U",id:"fields.U.inletValue",type:"double",size:3,"default":[0,0,0]}]},transport:{label:"Transport settings",parameters:[{label:"Model",id:"transport.model",type:"string",ui:"enum",size:1,"default":["Newtonian"],domain:{Newtonian:"Newtonian",BirdCarreau:"BirdCarreau",CrossPowerLaw:"CrossPowerLaw",powerLaw:"powerLaw",HerschelBulkley:"HerschelBulkley",Casson:"Casson"}},["Newtonian","BirdCarreau","CrossPowerLaw","powerLaw","HerschelBulkley","Casson"]],children:{Newtonian:"transport['transport.model'][0] === 'Newtonian'",BirdCarreau:"transport['transport.model'][0] === 'BirdCarreau'",CrossPowerLaw:"transport['transport.model'][0] === 'CrossPowerLaw'",powerLaw:"transport['transport.model'][0] === 'powerLaw'",HerschelBulkley:"transport['transport.model'][0] === 'HerschelBulkley'",Casson:"transport['transport.model'][0] === 'Casson'"}},Newtonian:{parameters:[{label:"Nu",id:"Newtonian.nu.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu Epsilon",id:"Newtonian.nu.epsilon",type:"double",size:1,"default":15e-6}]},BirdCarreau:{parameters:[{label:"Nu 0",id:"BirdCarreau.nu0.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu 0 Epsilon",id:"BirdCarreau.nu0.epsilon",type:"double",size:1,"default":.001},{label:"Nu Inf",id:"BirdCarreau.nuInf.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu Inf Epsilon",id:"BirdCarreau.nuInf.epsilon",type:"double",size:1,"default":1e-5},{label:"k",id:"BirdCarreau.k.dimensions",type:"double",size:7,"default":[0,0,1,0,0,0,0]},{label:"k Epsilon",id:"BirdCarreau.k.epsilon",type:"double",size:1,"default":1},{label:"n",id:"BirdCarreau.n.dimensions",type:"double",size:7,"default":[0,0,0,0,0,0,0]},{label:"n Epsilon",id:"BirdCarreau.n.epsilon",type:"double",size:1,"default":.5}]},CrossPowerLaw:{parameters:[{label:"Nu 0",id:"CrossPowerLaw.nu0.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu 0 Epsilon",id:"CrossPowerLaw.nu0.epsilon",type:"double",size:1,"default":.001},{label:"Nu Inf",id:"CrossPowerLaw.nuInf.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu Inf Epsilon",id:"CrossPowerLaw.nuInf.epsilon",type:"double",size:1,"default":1e-5},{label:"m",id:"CrossPowerLaw.m.dimensions",type:"double",size:7,"default":[0,0,1,0,0,0,0]},{label:"m Epsilon",id:"CrossPowerLaw.m.epsilon",type:"double",size:1,"default":1},{label:"n",id:"CrossPowerLaw.n.dimensions",type:"double",size:7,"default":[0,0,0,0,0,0,0]},{label:"n Epsilon",id:"CrossPowerLaw.n.epsilon",type:"double",size:1,"default":.5}]},powerLaw:{parameters:[{label:"Nu Max",id:"powerLaw.nuMax.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu Max Epsilon",id:"powerLaw.nuMax.epsilon",type:"double",size:1,"default":.001},{label:"Nu Min",id:"powerLaw.nuMin.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu Min Epsilon",id:"powerLaw.nuMin.epsilon",type:"double",size:1,"default":1e-5},{label:"k",id:"powerLaw.k.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"k Epsilon",id:"powerLaw.k.epsilon",type:"double",size:1,"default":1e-5},{label:"n",id:"powerLaw.n.dimensions",type:"double",size:7,"default":[0,0,0,0,0,0,0]},{label:"n Epsilon",id:"powerLaw.n.epsilon",type:"double",size:1,"default":1}]},HerschelBulkley:{parameters:[{label:"Nu 0",id:"HerschelBulkley.nu0.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"Nu 0 Epsilon",id:"HerschelBulkley.nu0.epsilon",type:"double",size:1,"default":.001},{label:"Tau 0",id:"HerschelBulkley.tau0.dimensions",type:"double",size:7,"default":[0,2,-2,0,0,0,0]},{label:"Tau 0 Epsilon",id:"HerschelBulkley.tau0.epsilon",type:"double",size:1,"default":1},{label:"k",id:"HerschelBulkley.k.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"k Epsilon",id:"HerschelBulkley.k.epsilon",type:"double",size:1,"default":1e-5},{label:"n",id:"HerschelBulkley.n.dimensions",type:"double",size:7,"default":[0,0,0,0,0,0,0]},{label:"n Epsilon",id:"HerschelBulkley.n.epsilon",type:"double",size:1,"default":1}]},Casson:{parameters:[{label:"m",id:"Casson.m.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"m Epsilon",id:"Casson.m.epsilon",type:"double",size:1,"default":3934986e-12},{label:"Tau 0",id:"Casson.tau0.dimensions",type:"double",size:7,"default":[0,2,-2,0,0,0,0]},{label:"Tau 0 Epsilon",id:"Casson.tau0.epsilon",type:"double",size:1,"default":29032e-10},{label:"nuMax",id:"Casson.nuMax.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"nuMax Epsilon",id:"Casson.nuMax.epsilon",type:"double",size:1,"default":133333e-10},{label:"nuMin",id:"Casson.nuMin.dimensions",type:"double",size:7,"default":[0,2,-1,0,0,0,0]},{label:"nuMin Epsilon",id:"Casson.nuMin.epsilon",type:"double",size:1,"default":39047e-10}]},wallBounds:{label:"Bounds of wind tunnel",parameters:[{label:"X",id:"tunnel.bounds.x",type:"double",size:2,"default":[-5,15]},{label:"Y",id:"tunnel.bounds.y",type:"double",size:2,"default":[-4,4]},{label:"Z",id:"tunnel.bounds.z",type:"double",size:2,"default":[0,8]}]},wallAssign:{label:"Walls orientations",parameters:[{label:"Wall normal to X (positive side)",id:"tunnel.walls.x.plus",type:"string",ui:"enum",size:1,"default":["outlet"],domain:{outlet:"outlet",inlet:"inlet",leftWall:"leftWall",rightWall:"rightWall",topWall:"topWall",bottomWall:"bottomWall"}},{label:"Wall normal to X (negative side)",id:"tunnel.walls.x.minus",type:"string",ui:"enum",size:1,"default":["inlet"],domain:{outlet:"outlet",inlet:"inlet",leftWall:"leftWall",rightWall:"rightWall",topWall:"topWall",bottomWall:"bottomWall"}},{label:"Wall normal to Y (positive side)",id:"tunnel.walls.y.plus",type:"string",ui:"enum",size:1,"default":["rightWall"],domain:{outlet:"outlet",inlet:"inlet",leftWall:"leftWall",rightWall:"rightWall",topWall:"topWall",bottomWall:"bottomWall"}},{label:"Wall normal to Y (negative side)",id:"tunnel.walls.y.minus",type:"string",ui:"enum",size:1,"default":["leftWall"],domain:{outlet:"outlet",inlet:"inlet",leftWall:"leftWall",rightWall:"rightWall",topWall:"topWall",bottomWall:"bottomWall"}},{label:"Wall normal to Z (positive side)",id:"tunnel.walls.z.plus",type:"string",ui:"enum",size:1,"default":["topWall"],domain:{outlet:"outlet",inlet:"inlet",leftWall:"leftWall",rightWall:"rightWall",topWall:"topWall",bottomWall:"bottomWall"}},{label:"Wall normal to Z (negative side)",id:"tunnel.walls.z.minus",type:"string",ui:"enum",size:1,"default":["bottomWall"],domain:{outlet:"outlet",inlet:"inlet",leftWall:"leftWall",rightWall:"rightWall",topWall:"topWall",bottomWall:"bottomWall"}}]},"controldict-time":{label:"Time control",parameters:[{label:"Start time of the simulation",id:"controldict.time.startFrom",type:"string",ui:"enum",size:1,"default":["startTime"],domain:{startTime:"startTime",firstTime:"firstTime",latestTime:"latestTime"}},["controldict-time-startTime"],{label:"End time",id:"controldict.time.end",type:"double",size:1,"default":[500]},{label:"Delta time",id:"controldict.time.delta",type:"double",size:1,"default":[1]}],children:{"controldict-time-startTime":"controldict.time['controldict.time.startFrom'][0] === 'startTime'"}},"controldict-time-startTime":{parameters:[{label:"Start time",id:"controldict.time.startTime",type:"double",size:1,"default":[0]}]},"controldict-write":{label:"Output parameters",parameters:[{label:"Write control",id:"controldict.write.control",type:"string",ui:"enum",size:1,"default":["timeStep"],domain:{timeStep:"timeStep",runTime:"runTime",adjustableRunTime:"adjustableRunTime",cpuTime:"cpuTime",clockTime:"clockTime"}},{label:"Write interval",id:"controldict.write.interval",type:"double",size:1,"default":[100]},{label:"Write format",id:"controldict.write.format",type:"string",ui:"enum",size:1,"default":["binary"],domain:{ascii:"ascii",binary:"binary"}},{label:"Write precision",id:"controldict.write.precision",type:"integer",size:1,"default":[6]},{label:"Compress",id:"controldict.write.gzip",type:"string",ui:"enum",size:1,"default":["yes"],domain:{yes:"yes",no:"no"}},{label:"Time format",id:"controldict.write.time.format",type:"string",ui:"enum",size:1,"default":["general"],domain:{general:"general",fixed:"fixed",scientific:"scientific"}},{label:"Time precision",id:"controldict.write.time.precision",type:"integer",size:1,"default":[6]},{label:"Graph format",id:"controldict.write.graph.format",type:"string",ui:"enum",size:1,"default":["raw"],domain:{raw:"raw",gnuplot:"gnuplot",xmgr:"xmgr",jplot:"jplot"}}]},decomposeParDict:{label:"Decomposition",parameters:[{label:"Number of subdomains",id:"decomposeParDict.subdomains",type:"integer",size:1,"default":[6]},{label:"Method",id:"decomposeParDict.method",type:"string",ui:"enum",size:1,"default":["hierarchical"],domain:{hierarchical:"hierarchical",ptscotch:"ptscotch"}}]},decomposition_simpleCoeffs:{label:"Simple Coeffs",parameters:[{label:"n",id:"decomposeParDict.simpleCoeffs.n",type:"double",size:3,"default":[4,1,1]},{label:"delta",id:"decomposeParDict.simpleCoeffs.delta",type:"double",size:1,"default":[.001]}]},decomposition_hierarchicalCoeffs:{label:"Hierarchical Coeffs",parameters:[{label:"n",id:"decomposeParDict.hierarchicalCoeffs.n",type:"double",size:3,"default":[3,2,1]},{label:"delta",id:"decomposeParDict.hierarchicalCoeffs.delta",type:"double",size:1,"default":[.001]},{label:"order",id:"decomposeParDict.hierarchicalCoeffs.order",type:"string",ui:"enum",size:1,"default":["xyz"],domain:{xyz:"xyz",xzy:"xzy",yxz:"yxz",yzx:"yzx",zyx:"zyx",zxy:"zxy"}}]},forceCoeffs:{label:"Force analysis",parameters:[{label:"Write control",id:"forceCoeffs.write.control",type:"string",ui:"enum",size:1,"default":["timeStep"],domain:{timeStep:"timeStep",runTime:"runTime",adjustableRunTime:"adjustableRunTime",cpuTime:"cpuTime",clockTime:"clockTime"}},{label:"Write interval",id:"forceCoeffs.write.interval",type:"double",size:1,"default":[1]},{label:"Log",id:"forceCoeffs.write.log",type:"string",ui:"enum",size:1,"default":["yes"],domain:{yes:"yes",no:"no"}},{label:"liftDir",id:"forceCoeffs.liftDir",type:"double",size:3,"default":[0,0,1]},{label:"dragDir",id:"forceCoeffs.dragDir",type:"double",size:3,"default":[1,0,0]},{label:"CofR",id:"forceCoeffs.CofR",type:"double",size:3,"default":[.72,0,0]},{label:"pitchAxis",id:"forceCoeffs.pitchAxis",type:"double",size:3,"default":[0,1,0]},{label:"magUInf",id:"forceCoeffs.magUInf",type:"double",size:1,"default":[20]},{label:"lRef",id:"forceCoeffs.lRef",type:"double",size:1,"default":[1.42]},{label:"Aref",id:"forceCoeffs.Aref",type:"double",size:1,"default":[.75]}]},"solver-p":{label:"p",parameters:[{label:"Solver type",id:"solver.p.solver",type:"string",ui:"enum",size:1,"default":["GAMG"],domain:{GAMG:"GAMG",smoothSolver:"smoothSolver",PBiCG:"PBiCG"}},{label:"Smoother",id:"solver.p.smoother",type:"string",ui:"enum",size:1,"default":["GaussSeidel"],domain:{GaussSeidel:"Gauss-Seidel",symGaussSeidel:"symmetric Gauss-Seidel","DIC/DILU":"diagonal incomplete-Cholesky (symmetric), incomplete-LU (asymmetric)",DICGaussSeidel:"diagonal incomplete-Cholesky/LU with Gauss-Seidel (symmetric/asymmetric)"}},{label:"Tolerance",id:"solver.p.tolerance",type:"double",size:1,"default":[1e-7]},{label:"Relative Tolerance",id:"solver.p.relTol",type:"double",size:1,"default":[.01]}]},"solver-U":{label:"U",parameters:[{label:"Solver type",id:"solver.U.solver",type:"string",ui:"enum",size:1,"default":["smoothSolver"],domain:{GAMG:"GAMG",smoothSolver:"smoothSolver",PBiCG:"PBiCG"}},{label:"Smoother",id:"solver.U.smoother",type:"string",ui:"enum",size:1,"default":["GaussSeidel"],domain:{GaussSeidel:"Gauss-Seidel",symGaussSeidel:"symmetric Gauss-Seidel","DIC/DILU":"diagonal incomplete-Cholesky (symmetric), incomplete-LU (asymmetric)",DICGaussSeidel:"diagonal incomplete-Cholesky/LU with Gauss-Seidel (symmetric/asymmetric)"}},{label:"Tolerance",id:"solver.U.tolerance",type:"double",size:1,"default":[1e-8]},{label:"Relative Tolerance",id:"solver.U.relTol",type:"double",size:1,"default":[.1]},{label:"nSweeps",id:"solver.U.nSweeps",type:"integer",size:1,"default":[1]}]},"solver-k":{label:"k",parameters:[{label:"Solver type",id:"solver.k.solver",type:"string",ui:"enum",size:1,"default":["smoothSolver"],domain:{GAMG:"GAMG",smoothSolver:"smoothSolver",PBiCG:"PBiCG"}},{label:"Smoother",id:"solver.k.smoother",type:"string",ui:"enum",size:1,"default":["GaussSeidel"],domain:{GaussSeidel:"Gauss-Seidel",symGaussSeidel:"symmetric Gauss-Seidel","DIC/DILU":"diagonal incomplete-Cholesky (symmetric), incomplete-LU (asymmetric)",DICGaussSeidel:"diagonal incomplete-Cholesky/LU with Gauss-Seidel (symmetric/asymmetric)"}},{label:"Tolerance",id:"solver.k.tolerance",type:"double",size:1,"default":[1e-8]},{label:"Relative Tolerance",id:"solver.k.relTol",type:"double",size:1,"default":[.1]},{label:"nSweeps",id:"solver.k.nSweeps",type:"integer",size:1,"default":[1]}]},"solver-omega":{label:"omega",parameters:[{label:"Solver type",id:"solver.omega.solver",type:"string",ui:"enum",size:1,"default":["smoothSolver"],domain:{GAMG:"GAMG",smoothSolver:"smoothSolver",PBiCG:"PBiCG"}},{label:"Smoother",id:"solver.omega.smoother",type:"string",ui:"enum",size:1,"default":["GaussSeidel"],domain:{GaussSeidel:"Gauss-Seidel",symGaussSeidel:"symmetric Gauss-Seidel","DIC/DILU":"diagonal incomplete-Cholesky (symmetric), incomplete-LU (asymmetric)",DICGaussSeidel:"diagonal incomplete-Cholesky/LU with Gauss-Seidel (symmetric/asymmetric)"}},{label:"Tolerance",id:"solver.omega.tolerance",type:"double",size:1,"default":[1e-8]},{label:"Relative Tolerance",id:"solver.omega.relTol",type:"double",size:1,"default":[.1]},{label:"nSweeps",id:"solver.omega.nSweeps",type:"integer",size:1,"default":[1]}]},correctors:{label:"Correctors",parameters:[{label:"Simple nNonOrthogonalCorrectors",id:"correctors.simple.nNonOrthogonalCorrectors",type:"double",size:1,"default":[0]},{label:"Simple consistent",id:"correctors.simple..consistent",type:"string",ui:"enum",size:1,"default":["yes"],domain:{yes:"yes",no:"no"}},{label:"PotentialFlow nNonOrthogonalCorrectors",id:"correctors.potentialFlow.nNonOrthogonalCorrectors",type:"double",size:1,"default":[10]}]},relaxationFactors:{label:"Relaxation Factors",parameters:[{label:"U",id:"relaxationFactors.equations.U",type:"double",size:1,"default":[.9]},{label:"k",id:"relaxationFactors.equations.k",type:"double",size:1,"default":[.7]},{label:"omega",id:"relaxationFactors.equations.omega",type:"double",size:1,"default":[.7]}]},meshQuality:{label:"Mesh quality",parameters:[{label:"minFaceWeight",id:"meshQuality.minFaceWeight",type:"double",size:1,"default":[.02]}]},meshRefinement:{label:"Mesh Refinement",parameters:[{label:"Type",id:"meshRefinement.refinementBox.type",type:"string",ui:"enum",size:1,"default":["searchableBox"],domain:{searchableBox:"searchableBox",searchableSphere:"searchableSphere"}},["searchableBox","searchableSphere"]],children:{searchableBox:"meshRefinement['meshRefinement.refinementBox.type'][0] === 'searchableBox'",searchableSphere:"meshRefinement['meshRefinement.refinementBox.type'][0] === 'searchableSphere'"}},searchableBox:{parameters:[{label:"Refinement Box (min)",id:"meshRefinement.refinementBox.min",type:"double",size:3,"default":[-1,-.7,0]},{label:"Refinement Box (max)",id:"meshRefinement.refinementBox.max",type:"double",size:3,"default":[8,.7,2.5]}]},searchableSphere:{parameters:[{label:"Refinement Sphere (center)",id:"meshRefinement.refinementSphere.center",type:"double",size:3,"default":[0,0,0]},{label:"Refinement Sphere (radius)",id:"meshRefinement.refinementSphere.radius",type:"double",size:1,"default":[1.05]}]},runtime:{label:"Runtime step",parameters:[{label:"Type",id:"runtime.step",type:"string",ui:"enum",size:1,"default":["castellatedMesh"],domain:{castellatedMesh:"castellatedMesh",snap:"snap",addLayers:"addLayers"}},["castellatedMeshControls","snapControls","addLayersControls"]],children:{castellatedMeshControls:"runtime['runtime.step'][0] === 'castellatedMesh'",snapControls:"runtime['runtime.step'][0] === 'snap'",addLayersControls:"runtime['runtime.step'][0] === 'addLayers'"}},castellatedMeshControls:{label:"Castellated Mesh Controls",parameters:[{label:"maxLocalCells",id:"castellatedMeshControls.maxLocalCells",type:"integer",size:1,"default":[1e5]},{label:"maxGlobalCells",id:"castellatedMeshControls.maxGlobalCells",type:"integer",size:1,"default":[2e6]},{label:"minRefinementCells",id:"castellatedMeshControls.minRefinementCells",type:"integer",size:1,"default":[10]},{label:"maxLoadUnbalance",id:"castellatedMeshControls.maxLoadUnbalance",type:"double",size:1,"default":[.1]},{label:"nCellsBetweenLevels",id:"castellatedMeshControls.nCellsBetweenLevels",type:"integer",size:1,"default":[3]},{label:"resolveFeatureAngle",id:"castellatedMeshControls.resolveFeatureAngle",type:"integer",size:1,"default":[30]},{label:"locationInMesh",id:"castellatedMeshControls.locationInMesh",type:"double",size:3,"default":[3.0001,3.0001,.43]},{label:"allowFreeStandingZoneFaces",id:"castellatedMeshControls.allowFreeStandingZoneFaces",type:"string",ui:"enum",size:1,"default":["true"],domain:{"true":"true","false":"false"}}]},snapControls:{parameters:[{label:"nSmoothPatch",id:"snapControls.nSmoothPatch",type:"double",size:1,"default":[3]},{label:"tolerance",id:"snapControls.tolerance",type:"double",size:1,"default":[2]},{label:"nSolveIter",id:"snapControls.nSolveIter",type:"integer",size:1,"default":[30]},{label:"nRelaxIter",id:"snapControls.nRelaxIter",type:"integer",size:1,"default":[5]},{label:"nFeatureSnapIter",id:"snapControls.nFeatureSnapIter",type:"integer",size:1,"default":[10]},{label:"implicitFeatureSnap",id:"snapControls.implicitFeatureSnap",type:"string",ui:"enum",size:1,"default":["false"],domain:{"true":"true","false":"false"}},{label:"explicitFeatureSnap",id:"snapControls.explicitFeatureSnap",type:"string",ui:"enum",size:1,"default":["true"],domain:{"true":"true","false":"false"}},{label:"multiRegionFeatureSnap",id:"snapControls.multiRegionFeatureSnap",type:"string",ui:"enum",size:1,"default":["false"],domain:{"true":"true","false":"false"}}]},addLayersControls:{parameters:[{label:"relativeSizes",id:"addLayersControls.relativeSizes",type:"string",ui:"enum",size:1,"default":["true"],domain:{"true":"true","false":"false"}},{label:"expansionRatio",id:"addLayersControls.expansionRatio",type:"double",size:1,"default":[1]},{label:"finalLayerThickness",id:"addLayersControls.finalLayerThickness",type:"double",size:1,"default":[.3]},{label:"minThickness",id:"addLayersControls.minThickness",type:"double",size:1,"default":[.1]},{label:"nGrow",id:"addLayersControls.nGrow",type:"double",size:1,"default":[0]},{label:"",id:"addLayersControls.",type:"double",size:1,"default":[]},{label:"featureAngle",id:"addLayersControls.featureAngle",type:"double",size:1,"default":[60]},{label:"slipFeatureAngle",id:"addLayersControls.slipFeatureAngle",type:"double",size:1,"default":[30]},{label:"nRelaxIter",id:"addLayersControls.nRelaxIter",type:"integer",size:1,"default":[3]},{label:"nSmoothSurfaceNormals",id:"addLayersControls.nSmoothSurfaceNormals",type:"double",size:1,"default":[1]},{label:"nSmoothNormals",id:"addLayersControls.nSmoothNormals",type:"double",size:1,"default":[3]},{label:"nSmoothThickness",id:"addLayersControls.nSmoothThickness",type:"double",size:1,"default":[10]},{label:"maxFaceThicknessRatio",id:"addLayersControls.maxFaceThicknessRatio",type:"double",size:1,"default":[.5]},{label:"maxThicknessToMedialRatio",id:"addLayersControls.maxThicknessToMedialRatio",type:"double",size:1,"default":[.3]},{label:"minMedianAxisAngle",id:"addLayersControls.minMedianAxisAngle",type:"double",size:1,"default":[90]},{label:"nBufferCellsNoExtrude",id:"addLayersControls.nBufferCellsNoExtrude",type:"integer",size:1,"default":[0]},{label:"nLayerIter",id:"addLayersControls.nLayerIter",type:"integer",size:1,"default":[50]}]}}}},function(e,n,l){"use strict";e.exports={en:l(4)}},function(e,n,l){"use strict";e.exports={help:l(5),"label.json":l(8)}},function(e,n,l){"use strict";e.exports={example:l(6)}},function(e,n,l){"use strict";e.exports={"example.path":l(7)}},function(e,n){e.exports="<p>Choose the path to the corresponding example of the OpenFOAM tutorial</p>"},function(e,n){e.exports={views:{ExampleSelection:"OpenFOAM Tutorial"},attributes:{example:{title:"Example selection",parameters:{"example.path":"Path"}}}}},function(e,n,l){"use strict";var t={"0.orig/include/fixedInlet":l(10),"0.orig/include/frontBackUpperPatches":l(30),"0.orig/include/initialConditions":l(31),"0.orig/k":l(32),"0.orig/nut":l(33),"0.orig/omega":l(34),"0.orig/p":l(35),"0.orig/U":l(36),"constant/transportProperties":l(37),"constant/turbulenceProperties":l(38),"system/blockMeshDict":l(39),"system/controlDict":l(40),"system/decomposeParDict":l(41),"system/forceCoeffs":l(42),"system/fvSchemes":l(43),"system/fvSolution":l(44),"system/meshQualityDict":l(45),"system/snappyHexMeshDict":l(46),"system/surfaceFeatureExtractDict":l(47),Allclean:l(48),Allrun:l(49)};e.exports=function(e){var n={},l=[],a={initialConditions:{flowVelocity:[20,0,0],pressure:0,turbulentKE:.24,turbulentOmega:1.78},meshGroupName:"motorBikeGroup",k:{dimensions:[0,2,-2,0,0,0,0]},nut:{dimensions:[0,2,-1,0,0,0,0]},omega:{dimensions:[0,0,-1,0,0,0,0]},p:{dimensions:[0,2,-2,0,0,0,0]},U:{dimensions:[0,1,-1,0,0,0,0],inletValue:[0,0,0]},transport:{model:"Newtonian",dimensions:[0,2,-1,0,0,0,0],epsilon:15e-6},tunnel:{bounds:[-5,15,-4,4,0,8],simpleGrading:[1,1,1],walls:{x:{plus:"outlet",minus:"inlet"},y:{plus:"rightWall",minus:"leftWall"},z:{plus:"topWall",minus:"bottomWall"}}},controls:{startTime:0,endTime:500,deltaT:1,writeControl:"timeStep",writeInterval:100,purgeWrite:0,writeFormat:"binary",writePrecision:6,writeCompression:"uncompressed",timeFormat:"general",timePrecision:6,runTimeModifiable:"true"},decompose:{numberOfSubdomains:6,method:"hierarchical",simpleCoeffs:{n:[4,1,1],delta:.001},hierarchicalCoeffs:{n:[3,2,1],delta:.001,order:"xyz"}},forceCoeffs:{writeControl:"timeStep",timeInterval:1,log:"yes",patches:["motorBikeGroup"],liftDir:[0,0,1],dragDir:[1,0,0],CofR:[.72,0,0],pitchAxis:[0,1,0],magUInf:20,lRef:1.42,Aref:.75},solvers:{p:{solver:"GAMG",tolerance:1e-7,relTol:.01,smoother:"GaussSeidel"},U:{solver:"smoothSolver",smoother:"GaussSeidel",tolerance:1e-8,relTol:.1,nSweeps:1},k:{solver:"smoothSolver",smoother:"GaussSeidel",tolerance:1e-8,relTol:.1,nSweeps:1},omega:{solver:"smoothSolver",smoother:"GaussSeidel",tolerance:1e-8,relTol:.1,nSweeps:1},correctors:{simple:{nNonOrthogonalCorrectors:0,consistent:"yes"},potentialFlow:{nNonOrthogonalCorrectors:10}}},relaxationFactors:{equations:{U:.9,k:.7,omega:.7}},meshQuality:{minFaceWeight:.02},hexMesh:{steps:["castellatedMesh","snap","addLayers"],geometry:{name:"motorBike",refinementBox:{type:"searchableBox",min:[-1,-.7,0],max:[8,.7,2.5]}},castellatedMeshControls:{maxLocalCells:1e5,maxGlobalCells:2e6,minRefinementCells:10,maxLoadUnbalance:.1,nCellsBetweenLevels:3,resolveFeatureAngle:30,locationInMesh:[3.0001,3.0001,.43],allowFreeStandingZoneFaces:"true"},snapControls:{nSmoothPatch:3,tolerance:2,nSolveIter:30,nRelaxIter:5,nFeatureSnapIter:10,implicitFeatureSnap:"false",explicitFeatureSnap:"true",multiRegionFeatureSnap:"false"},addLayersControls:{relativeSizes:"true",expansionRatio:1,finalLayerThickness:.3,minThickness:.1,nGrow:0,featureAngle:60,slipFeatureAngle:30,nRelaxIter:3,nSmoothSurfaceNormals:1,nSmoothNormals:3,nSmoothThickness:10,maxFaceThicknessRatio:.5,maxThicknessToMedialRatio:.3,minMedianAxisAngle:90,nBufferCellsNoExtrude:0,nLayerIter:50}}};return Object.keys(t).forEach(function(e){try{n[e]=t[e](a)}catch(o){var i="Error trying to convert model for generating "+e;l.push(i),console.log(i,o)}}),l.length||(l=null),{results:n,error:l}}},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\n\ninlet\n{\n    type  fixedValue;\n    value $internalField;\n}\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){e.exports=l(12)["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}function a(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var l in e)Object.prototype.hasOwnProperty.call(e,l)&&(n[l]=e[l]);return n["default"]=e,n}function o(){var e=new r.HandlebarsEnvironment;return p.extend(e,r),e.SafeString=u["default"],e.Exception=c["default"],e.Utils=p,e.escapeExpression=p.escapeExpression,e.VM=h,e.template=function(n){return h.template(n,e)},e}n.__esModule=!0;var i=l(13),r=a(i),s=l(27),u=t(s),d=l(15),c=t(d),m=l(14),p=a(m),f=l(28),h=a(f),b=l(29),y=t(b),v=o();v.create=o,y["default"](v),v["default"]=v,n["default"]=v,e.exports=n["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}function a(e,n,l){this.helpers=e||{},this.partials=n||{},this.decorators=l||{},s.registerDefaultHelpers(this),u.registerDefaultDecorators(this)}n.__esModule=!0,n.HandlebarsEnvironment=a;var o=l(14),i=l(15),r=t(i),s=l(16),u=l(24),d=l(26),c=t(d),m="4.0.5";n.VERSION=m;var p=7;n.COMPILER_REVISION=p;var f={1:"<= 1.0.rc.2",2:"== 1.0.0-rc.3",3:"== 1.0.0-rc.4",4:"== 1.x.x",5:"== 2.0.0-alpha.x",6:">= 2.0.0-beta.1",7:">= 4.0.0"};n.REVISION_CHANGES=f;var h="[object Object]";a.prototype={constructor:a,logger:c["default"],log:c["default"].log,registerHelper:function(e,n){if(o.toString.call(e)===h){if(n)throw new r["default"]("Arg not supported with multiple helpers");o.extend(this.helpers,e)}else this.helpers[e]=n},unregisterHelper:function(e){delete this.helpers[e]},registerPartial:function(e,n){if(o.toString.call(e)===h)o.extend(this.partials,e);else{if("undefined"==typeof n)throw new r["default"]('Attempting to register a partial called "'+e+'" as undefined');this.partials[e]=n}},unregisterPartial:function(e){delete this.partials[e]},registerDecorator:function(e,n){if(o.toString.call(e)===h){if(n)throw new r["default"]("Arg not supported with multiple decorators");o.extend(this.decorators,e)}else this.decorators[e]=n},unregisterDecorator:function(e){delete this.decorators[e]}};var b=c["default"].log;n.log=b,n.createFrame=o.createFrame,n.logger=c["default"]},function(e,n){"use strict";function l(e){return d[e]}function t(e){for(var n=1;n<arguments.length;n++)for(var l in arguments[n])Object.prototype.hasOwnProperty.call(arguments[n],l)&&(e[l]=arguments[n][l]);return e}function a(e,n){for(var l=0,t=e.length;l<t;l++)if(e[l]===n)return l;return-1}function o(e){if("string"!=typeof e){if(e&&e.toHTML)return e.toHTML();if(null==e)return"";if(!e)return e+"";e=""+e}return m.test(e)?e.replace(c,l):e}function i(e){return!e&&0!==e||!(!h(e)||0!==e.length)}function r(e){var n=t({},e);return n._parent=e,n}function s(e,n){return e.path=n,e}function u(e,n){return(e?e+".":"")+n}n.__esModule=!0,n.extend=t,n.indexOf=a,n.escapeExpression=o,n.isEmpty=i,n.createFrame=r,n.blockParams=s,n.appendContextPath=u;var d={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;","=":"&#x3D;"},c=/[&<>"'`=]/g,m=/[&<>"'`=]/,p=Object.prototype.toString;n.toString=p;var f=function(e){return"function"==typeof e};f(/x/)&&(n.isFunction=f=function(e){return"function"==typeof e&&"[object Function]"===p.call(e)}),n.isFunction=f;var h=Array.isArray||function(e){return!(!e||"object"!=typeof e)&&"[object Array]"===p.call(e)};n.isArray=h},function(e,n){"use strict";function l(e,n){var a=n&&n.loc,o=void 0,i=void 0;a&&(o=a.start.line,i=a.start.column,e+=" - "+o+":"+i);for(var r=Error.prototype.constructor.call(this,e),s=0;s<t.length;s++)this[t[s]]=r[t[s]];Error.captureStackTrace&&Error.captureStackTrace(this,l),a&&(this.lineNumber=o,this.column=i)}n.__esModule=!0;var t=["description","fileName","lineNumber","message","name","number","stack"];l.prototype=new Error,n["default"]=l,e.exports=n["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}function a(e){i["default"](e),s["default"](e),d["default"](e),m["default"](e),f["default"](e),b["default"](e),v["default"](e)}n.__esModule=!0,n.registerDefaultHelpers=a;var o=l(17),i=t(o),r=l(18),s=t(r),u=l(19),d=t(u),c=l(20),m=t(c),p=l(21),f=t(p),h=l(22),b=t(h),y=l(23),v=t(y)},function(e,n,l){"use strict";n.__esModule=!0;var t=l(14);n["default"]=function(e){e.registerHelper("blockHelperMissing",function(n,l){var a=l.inverse,o=l.fn;if(n===!0)return o(this);if(n===!1||null==n)return a(this);if(t.isArray(n))return n.length>0?(l.ids&&(l.ids=[l.name]),e.helpers.each(n,l)):a(this);if(l.data&&l.ids){var i=t.createFrame(l.data);i.contextPath=t.appendContextPath(l.data.contextPath,l.name),l={data:i}}return o(n,l)})},e.exports=n["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}n.__esModule=!0;var a=l(14),o=l(15),i=t(o);n["default"]=function(e){e.registerHelper("each",function(e,n){function l(n,l,o){u&&(u.key=n,u.index=l,u.first=0===l,u.last=!!o,d&&(u.contextPath=d+n)),s+=t(e[n],{data:u,blockParams:a.blockParams([e[n],n],[d+n,null])})}if(!n)throw new i["default"]("Must pass iterator to #each");var t=n.fn,o=n.inverse,r=0,s="",u=void 0,d=void 0;if(n.data&&n.ids&&(d=a.appendContextPath(n.data.contextPath,n.ids[0])+"."),a.isFunction(e)&&(e=e.call(this)),n.data&&(u=a.createFrame(n.data)),e&&"object"==typeof e)if(a.isArray(e))for(var c=e.length;r<c;r++)r in e&&l(r,r,r===e.length-1);else{
var m=void 0;for(var p in e)e.hasOwnProperty(p)&&(void 0!==m&&l(m,r-1),m=p,r++);void 0!==m&&l(m,r-1,!0)}return 0===r&&(s=o(this)),s})},e.exports=n["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}n.__esModule=!0;var a=l(15),o=t(a);n["default"]=function(e){e.registerHelper("helperMissing",function(){if(1!==arguments.length)throw new o["default"]('Missing helper: "'+arguments[arguments.length-1].name+'"')})},e.exports=n["default"]},function(e,n,l){"use strict";n.__esModule=!0;var t=l(14);n["default"]=function(e){e.registerHelper("if",function(e,n){return t.isFunction(e)&&(e=e.call(this)),!n.hash.includeZero&&!e||t.isEmpty(e)?n.inverse(this):n.fn(this)}),e.registerHelper("unless",function(n,l){return e.helpers["if"].call(this,n,{fn:l.inverse,inverse:l.fn,hash:l.hash})})},e.exports=n["default"]},function(e,n){"use strict";n.__esModule=!0,n["default"]=function(e){e.registerHelper("log",function(){for(var n=[void 0],l=arguments[arguments.length-1],t=0;t<arguments.length-1;t++)n.push(arguments[t]);var a=1;null!=l.hash.level?a=l.hash.level:l.data&&null!=l.data.level&&(a=l.data.level),n[0]=a,e.log.apply(e,n)})},e.exports=n["default"]},function(e,n){"use strict";n.__esModule=!0,n["default"]=function(e){e.registerHelper("lookup",function(e,n){return e&&e[n]})},e.exports=n["default"]},function(e,n,l){"use strict";n.__esModule=!0;var t=l(14);n["default"]=function(e){e.registerHelper("with",function(e,n){t.isFunction(e)&&(e=e.call(this));var l=n.fn;if(t.isEmpty(e))return n.inverse(this);var a=n.data;return n.data&&n.ids&&(a=t.createFrame(n.data),a.contextPath=t.appendContextPath(n.data.contextPath,n.ids[0])),l(e,{data:a,blockParams:t.blockParams([e],[a&&a.contextPath])})})},e.exports=n["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}function a(e){i["default"](e)}n.__esModule=!0,n.registerDefaultDecorators=a;var o=l(25),i=t(o)},function(e,n,l){"use strict";n.__esModule=!0;var t=l(14);n["default"]=function(e){e.registerDecorator("inline",function(e,n,l,a){var o=e;return n.partials||(n.partials={},o=function(a,o){var i=l.partials;l.partials=t.extend({},i,n.partials);var r=e(a,o);return l.partials=i,r}),n.partials[a.args[0]]=a.fn,o})},e.exports=n["default"]},function(e,n,l){"use strict";n.__esModule=!0;var t=l(14),a={methodMap:["debug","info","warn","error"],level:"info",lookupLevel:function(e){if("string"==typeof e){var n=t.indexOf(a.methodMap,e.toLowerCase());e=n>=0?n:parseInt(e,10)}return e},log:function(e){if(e=a.lookupLevel(e),"undefined"!=typeof console&&a.lookupLevel(a.level)<=e){var n=a.methodMap[e];console[n]||(n="log");for(var l=arguments.length,t=Array(l>1?l-1:0),o=1;o<l;o++)t[o-1]=arguments[o];console[n].apply(console,t)}}};n["default"]=a,e.exports=n["default"]},function(e,n){"use strict";function l(e){this.string=e}n.__esModule=!0,l.prototype.toString=l.prototype.toHTML=function(){return""+this.string},n["default"]=l,e.exports=n["default"]},function(e,n,l){"use strict";function t(e){return e&&e.__esModule?e:{"default":e}}function a(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var l in e)Object.prototype.hasOwnProperty.call(e,l)&&(n[l]=e[l]);return n["default"]=e,n}function o(e){var n=e&&e[0]||1,l=y.COMPILER_REVISION;if(n!==l){if(n<l){var t=y.REVISION_CHANGES[l],a=y.REVISION_CHANGES[n];throw new b["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version ("+t+") or downgrade your runtime to an older version ("+a+").")}throw new b["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version ("+e[1]+").")}}function i(e,n){function l(l,t,a){a.hash&&(t=f.extend({},t,a.hash),a.ids&&(a.ids[0]=!0)),l=n.VM.resolvePartial.call(this,l,t,a);var o=n.VM.invokePartial.call(this,l,t,a);if(null==o&&n.compile&&(a.partials[a.name]=n.compile(l,e.compilerOptions,n),o=a.partials[a.name](t,a)),null!=o){if(a.indent){for(var i=o.split("\n"),r=0,s=i.length;r<s&&(i[r]||r+1!==s);r++)i[r]=a.indent+i[r];o=i.join("\n")}return o}throw new b["default"]("The partial "+a.name+" could not be compiled when running in runtime-only mode")}function t(n){function l(n){return""+e.main(a,n,a.helpers,a.partials,i,s,r)}var o=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],i=o.data;t._setup(o),!o.partial&&e.useData&&(i=c(n,i));var r=void 0,s=e.useBlockParams?[]:void 0;return e.useDepths&&(r=o.depths?n!==o.depths[0]?[n].concat(o.depths):o.depths:[n]),(l=m(e.main,l,a,o.depths||[],i,s))(n,o)}if(!n)throw new b["default"]("No environment passed to template");if(!e||!e.main)throw new b["default"]("Unknown template object: "+typeof e);e.main.decorator=e.main_d,n.VM.checkRevision(e.compiler);var a={strict:function(e,n){if(!(n in e))throw new b["default"]('"'+n+'" not defined in '+e);return e[n]},lookup:function(e,n){for(var l=e.length,t=0;t<l;t++)if(e[t]&&null!=e[t][n])return e[t][n]},lambda:function(e,n){return"function"==typeof e?e.call(n):e},escapeExpression:f.escapeExpression,invokePartial:l,fn:function(n){var l=e[n];return l.decorator=e[n+"_d"],l},programs:[],program:function(e,n,l,t,a){var o=this.programs[e],i=this.fn(e);return n||a||t||l?o=r(this,e,i,n,l,t,a):o||(o=this.programs[e]=r(this,e,i)),o},data:function(e,n){for(;e&&n--;)e=e._parent;return e},merge:function(e,n){var l=e||n;return e&&n&&e!==n&&(l=f.extend({},n,e)),l},noop:n.VM.noop,compilerInfo:e.compiler};return t.isTop=!0,t._setup=function(l){l.partial?(a.helpers=l.helpers,a.partials=l.partials,a.decorators=l.decorators):(a.helpers=a.merge(l.helpers,n.helpers),e.usePartial&&(a.partials=a.merge(l.partials,n.partials)),(e.usePartial||e.useDecorators)&&(a.decorators=a.merge(l.decorators,n.decorators)))},t._child=function(n,l,t,o){if(e.useBlockParams&&!t)throw new b["default"]("must pass block params");if(e.useDepths&&!o)throw new b["default"]("must pass parent depths");return r(a,n,e[n],l,0,t,o)},t}function r(e,n,l,t,a,o,i){function r(n){var a=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],r=i;return i&&n!==i[0]&&(r=[n].concat(i)),l(e,n,e.helpers,e.partials,a.data||t,o&&[a.blockParams].concat(o),r)}return r=m(l,r,e,i,t,o),r.program=n,r.depth=i?i.length:0,r.blockParams=a||0,r}function s(e,n,l){return e?e.call||l.name||(l.name=e,e=l.partials[e]):e="@partial-block"===l.name?l.data["partial-block"]:l.partials[l.name],e}function u(e,n,l){l.partial=!0,l.ids&&(l.data.contextPath=l.ids[0]||l.data.contextPath);var t=void 0;if(l.fn&&l.fn!==d&&(l.data=y.createFrame(l.data),t=l.data["partial-block"]=l.fn,t.partials&&(l.partials=f.extend({},l.partials,t.partials))),void 0===e&&t&&(e=t),void 0===e)throw new b["default"]("The partial "+l.name+" could not be found");if(e instanceof Function)return e(n,l)}function d(){return""}function c(e,n){return n&&"root"in n||(n=n?y.createFrame(n):{},n.root=e),n}function m(e,n,l,t,a,o){if(e.decorator){var i={};n=e.decorator(n,i,l,t&&t[0],a,o,t),f.extend(n,i)}return n}n.__esModule=!0,n.checkRevision=o,n.template=i,n.wrapProgram=r,n.resolvePartial=s,n.invokePartial=u,n.noop=d;var p=l(14),f=a(p),h=l(15),b=t(h),y=l(13)},function(e,n){(function(l){"use strict";n.__esModule=!0,n["default"]=function(e){var n="undefined"!=typeof l?l:window,t=n.Handlebars;e.noConflict=function(){return n.Handlebars===e&&(n.Handlebars=t),e}},e.exports=n["default"]}).call(n,function(){return this}())},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\n\ntopWall\n{\n    type slip;\n}\n\nleftWall\n{\n    type slip;\n}\n\nrightWall\n{\n    type slip;\n}\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=e.lambda;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\n\nflowVelocity         ("+(null!=(o=(l.vector||n&&n.vector||l.helperMissing).call(null!=n?n:{},null!=(o=null!=n?n.initialConditions:n)?o.flowVelocity:o,{name:"vector",hash:{},data:a}))?o:"")+");\npressure             "+(null!=(o=i(null!=(o=null!=n?n.initialConditions:n)?o.pressure:o,n))?o:"")+";\nturbulentKE          "+(null!=(o=i(null!=(o=null!=n?n.initialConditions:n)?o.turbulentKE:o,n))?o:"")+";\nturbulentOmega       "+(null!=(o=i(null!=(o=null!=n?n.initialConditions:n)?o.turbulentOmega:o,n))?o:"")+";\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i,r=null!=n?n:{},s=l.helperMissing;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       volScalarField;\n    object      k;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n#include        "include/initialConditions"\n\ndimensions      ['+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.k:n)?o.dimensions:o,{name:"vector",hash:{},data:a}))?o:"")+'];\n\ninternalField   uniform $turbulentKE;\n\nboundaryField\n{\n    //- Set patchGroups for constraint patches\n    #includeEtc "caseDicts/setConstraintTypes"\n\n    //- Define inlet conditions\n    #include "include/fixedInlet"\n\n    outlet\n    {\n        type            inletOutlet;\n        inletValue      $internalField;\n        value           $internalField;\n    }\n\n    //- This should probably be on a condition\n    bottomWall\n    {\n        type            kqRWallFunction;\n        value           $internalField;\n    }\n\n    '+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:s,o="function"==typeof i?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+'\n    {\n        type            kqRWallFunction;\n        value           $internalField;\n    }\n\n    #include "include/frontBackUpperPatches"\n}\n\n\n// ************************************************************************* //\n'},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i,r=null!=n?n:{},s=l.helperMissing;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       volScalarField;\n    location    "0";\n    object      nut;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\ndimensions      ['+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.nut:n)?o.dimensions:o,{name:"vector",hash:{},data:a}))?o:"")+'];\n\ninternalField   uniform 0;\n\nboundaryField\n{\n    //- Set patchGroups for constraint patches\n    #includeEtc "caseDicts/setConstraintTypes"\n\n    leftWall\n    {\n        type            calculated;\n        value           uniform 0;\n    }\n\n    rightWall\n    {\n        type            calculated;\n        value           uniform 0;\n    }\n\n    inlet\n    {\n        type            calculated;\n        value           uniform 0;\n    }\n\n    outlet\n    {\n        type            calculated;\n        value           uniform 0;\n    }\n\n    bottomWall\n    {\n        type            nutkWallFunction;\n        value           uniform 0;\n    }\n\n    topWall\n    {\n        type            calculated;\n        value           uniform 0;\n    }\n\n    '+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:s,o="function"==typeof i?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+"\n    {\n        type            nutkWallFunction;\n        value           uniform 0;\n    }\n}\n\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i,r=null!=n?n:{},s=l.helperMissing;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       volScalarField;\n    object      omega;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n#include        "include/initialConditions"\n\ndimensions      ['+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.omega:n)?o.dimensions:o,{name:"vector",hash:{},data:a}))?o:"")+'];\n\ninternalField   uniform $turbulentOmega;\n\nboundaryField\n{\n    //- Set patchGroups for constraint patches\n    #includeEtc "caseDicts/setConstraintTypes"\n\n    #include "include/fixedInlet"\n\n    outlet\n    {\n        type            inletOutlet;\n        inletValue      $internalField;\n        value           $internalField;\n    }\n\n    bottomWall\n    {\n        type            omegaWallFunction;\n        value           $internalField;\n    }\n\n    '+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:s,o="function"==typeof i?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+'\n    {\n        type            omegaWallFunction;\n        value           $internalField;\n    }\n\n    #include "include/frontBackUpperPatches"\n}\n\n\n// ************************************************************************* //\n'},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i,r=null!=n?n:{},s=l.helperMissing;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       volScalarField;\n    object      p;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n#include        "include/initialConditions"\n\ndimensions      ['+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.p:n)?o.dimensions:o,{name:"vector",hash:{},data:a}))?o:"")+'];\n\ninternalField   uniform $pressure;\n\nboundaryField\n{\n    //- Set patchGroups for constraint patches\n    #includeEtc "caseDicts/setConstraintTypes"\n\n    inlet\n    {\n        type            zeroGradient;\n    }\n\n    outlet\n    {\n        type            fixedValue;\n        value           $internalField;\n    }\n\n    bottomWall\n    {\n        type            zeroGradient;\n    }\n\n    '+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:s,o="function"==typeof i?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+'\n    {\n        type            zeroGradient;\n    }\n\n    #include "include/frontBackUpperPatches"\n}\n\n// ************************************************************************* //\n'},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i,r=null!=n?n:{},s=l.helperMissing;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       volVectorField;\n    location    "0";\n    object      U;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n#include        "include/initialConditions"\n\ndimensions      ['+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.U:n)?o.dimensions:o,{name:"vector",hash:{},data:a}))?o:"")+'];\n\ninternalField   uniform $flowVelocity;\n\nboundaryField\n{\n    //- Set patchGroups for constraint patches\n    #includeEtc "caseDicts/setConstraintTypes"\n\n    #include "include/fixedInlet"\n\n    outlet\n    {\n        type            inletOutlet;\n        inletValue      uniform ('+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.U:n)?o.inletValue:o,{name:"vector",hash:{},data:a}))?o:"")+");\n        value           $internalField;\n    }\n\n    bottomWall\n    {\n        type            fixedValue;\n        value           $internalField;\n    }\n\n    "+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:s,o="function"==typeof i?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+'\n    {\n        type            noSlip;\n    }\n\n    #include "include/frontBackUpperPatches"\n}\n\n\n// ************************************************************************* //\n'},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=e.lambda;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      transportProperties;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\ntransportModel  "+(null!=(o=i(null!=(o=null!=n?n.transport:n)?o.model:o,n))?o:"")+";\n\nnu              ["+(null!=(o=(l.vector||n&&n.vector||l.helperMissing).call(null!=n?n:{},null!=(o=null!=n?n.transport:n)?o.dimensions:o,{name:"vector",hash:{},data:a}))?o:"")+"] "+(null!=(o=i(null!=(o=null!=n?n.transport:n)?o.epsilon:o,n))?o:"")+";\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      turbulenceProperties;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nsimulationType RAS;\n\nRAS\n{\n    RASModel            kOmegaSST;\n\n    turbulence          on;\n\n    printCoeffs         on;\n}\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=null!=n?n:{},r=l.helperMissing,s=e.escapeExpression,u=e.lambda;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      blockMeshDict;\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nconvertToMeters 1;\n\nvertices\n(\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,0,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,2,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,4,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,1,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,2,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,4,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,1,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,3,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,4,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,0,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,3,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,4,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,0,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,2,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,5,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,1,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,2,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,5,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,1,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,3,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,5,{name:"item",hash:{},data:a}))+")\n    ("+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,0,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,3,{name:"item",hash:{},data:a}))+" "+s((l.item||n&&n.item||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,5,{name:"item",hash:{},data:a}))+")\n);\n\nblocks\n(\n    hex (0 1 2 3 4 5 6 7) ("+(null!=(o=(l.delta||n&&n.delta||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.bounds:o,{name:"delta",hash:{},data:a}))?o:"")+") simpleGrading ("+(null!=(o=(l.vector||n&&n.vector||r).call(i,null!=(o=null!=n?n.tunnel:n)?o.simpleGrading:o,{name:"vector",hash:{},data:a}))?o:"")+")\n);\n\nedges\n(\n);\n\nboundary\n(\n    "+(null!=(o=u(null!=(o=null!=(o=null!=n?n.walls:n)?o.x:o)?o.plus:o,n))?o:"")+"\n    {\n        type patch;\n        faces\n        (\n          (2 6 5 1)\n        )\n    }\n    "+(null!=(o=u(null!=(o=null!=(o=null!=n?n.walls:n)?o.x:o)?o.minus:o,n))?o:"")+"\n    {\n        type patch;\n        faces\n        (\n          (0 4 7 3)\n        )\n    }\n    "+(null!=(o=u(null!=(o=null!=(o=null!=n?n.walls:n)?o.y:o)?o.plus:o,n))?o:"")+"\n    {\n        type patch;\n        faces\n        (\n          (3 7 6 2)\n        )\n    }\n    "+(null!=(o=u(null!=(o=null!=(o=null!=n?n.walls:n)?o.y:o)?o.minus:o,n))?o:"")+"\n    {\n        type patch;\n        faces\n        (\n          (1 5 4 0)\n        )\n    }\n    "+(null!=(o=u(null!=(o=null!=(o=null!=n?n.walls:n)?o.z:o)?o.plus:o,n))?o:"")+"\n    {\n        type patch;\n        faces\n        (\n          (4 5 6 7)\n        )\n    }\n    "+(null!=(o=u(null!=(o=null!=(o=null!=n?n.walls:n)?o.z:o)?o.minus:o,n))?o:"")+"\n    {\n        type patch;\n        faces\n        (\n          (0 3 2 1)\n        )\n    }\n);\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=e.lambda;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      controlDict;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\napplication     simpleFoam;\n\nstartFrom       latestTime;\n\nstartTime       "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.startTime:o,n))?o:"")+";\n\nstopAt          endTime;\n\nendTime         "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.endTime:o,n))?o:"")+";\n\ndeltaT          "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.deltaT:o,n))?o:"")+";\n\nwriteControl    "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.writeControl:o,n))?o:"")+";\n\nwriteInterval   "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.writeInterval:o,n))?o:"")+";\n\npurgeWrite      "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.purgeWrite:o,n))?o:"")+";\n\nwriteFormat     "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.writeFormat:o,n))?o:"")+";\n\nwritePrecision  "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.writePrecision:o,n))?o:"")+";\n\nwriteCompression "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.writeCompression:o,n))?o:"")+";\n\ntimeFormat      "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.timeFormat:o,n))?o:"")+";\n\ntimePrecision   "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.timePrecision:o,n))?o:"")+";\n\nrunTimeModifiable "+(null!=(o=i(null!=(o=null!=n?n.controls:n)?o.runTimeModifiable:o,n))?o:"")+';\n\nfunctions\n{\n    #include "forceCoeffs"\n}\n\n\n// ************************************************************************* //\n'},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=e.lambda,r=null!=n?n:{},s=l.helperMissing;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      decomposeParDict;\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nnumberOfSubdomains "+(null!=(o=i(null!=(o=null!=n?n.decompose:n)?o.numberOfSubdomains:o,n))?o:"")+";\n\nmethod          "+(null!=(o=i(null!=(o=null!=n?n.decompose:n)?o.method:o,n))?o:"")+";\n\nsimpleCoeffs\n{\n    n               ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=(o=null!=n?n.decompose:n)?o.simpleCoeffs:o)?o.n:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    delta           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.decompose:n)?o.simpleCoeffs:o)?o.delta:o,n))?o:"")+";\n}\n\nhierarchicalCoeffs\n{\n    n               ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=(o=null!=n?n.decompose:n)?o.hierarchicalCoeffs:o)?o.n:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    delta           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.decompose:n)?o.hierarchicalCoeffs:o)?o.delta:o,n))?o:"")+";\n    order           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.decompose:n)?o.hierarchicalCoeffs:o)?o.order:o,n))?o:"")+';\n}\n\nmanualCoeffs\n{\n    dataFile        "cellDecomposition";\n}\n\n\n// ************************************************************************* //\n';
},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=e.lambda,r=null!=n?n:{},s=l.helperMissing;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\n\nforceCoeffs1\n{\n    type        forceCoeffs;\n\n    libs ( "libforces.so" );\n\n    writeControl   '+(null!=(o=i(null!=(o=null!=n?n.forceCoeffs:n)?o.writeControl:o,n))?o:"")+";\n    timeInterval   "+(null!=(o=i(null!=(o=null!=n?n.forceCoeffs:n)?o.timeInterval:o,n))?o:"")+";\n\n    log            "+(null!=(o=i(null!=(o=null!=n?n.forceCoeffs:n)?o.log:o,n))?o:"")+";\n\n    patches     ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.forceCoeffs:n)?o.patches:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    rho         rhoInf;      // Indicates incompressible\n    rhoInf      1;           // Redundant for incompressible\n    liftDir     ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.forceCoeffs:n)?o.liftDir:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    dragDir     ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.forceCoeffs:n)?o.dragDir:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    CofR        ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.forceCoeffs:n)?o.CofR:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    pitchAxis   ("+(null!=(o=(l.vector||n&&n.vector||s).call(r,null!=(o=null!=n?n.forceCoeffs:n)?o.pitchAxis:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    magUInf     "+(null!=(o=i(null!=(o=null!=n?n.forceCoeffs:n)?o.magUInf:o,n))?o:"")+";\n    lRef        "+(null!=(o=i(null!=(o=null!=n?n.forceCoeffs:n)?o.lRef:o,n))?o:"")+";\n    Aref        "+(null!=(o=i(null!=(o=null!=n?n.forceCoeffs:n)?o.Aref:o,n))?o:"")+";\n    /*\n    binData\n    {\n        nBin        20;          // output data into 20 bins\n        direction   (1 0 0);     // bin direction\n        cumulative  yes;\n    }\n    */\n}\n\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      fvSchemes;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nddtSchemes\n{\n    default         steadyState;\n}\n\ngradSchemes\n{\n    default         Gauss linear;\n    grad(U)         cellLimited Gauss linear 1;\n}\n\ndivSchemes\n{\n    default         none;\n    div(phi,U)      bounded Gauss linearUpwindV grad(U);\n    div(phi,k)      bounded Gauss upwind;\n    div(phi,omega)  bounded Gauss upwind;\n    div((nuEff*dev2(T(grad(U))))) Gauss linear;\n}\n\nlaplacianSchemes\n{\n    default         Gauss linear corrected;\n}\n\ninterpolationSchemes\n{\n    default         linear;\n}\n\nsnGradSchemes\n{\n    default         corrected;\n}\n\nwallDist\n{\n    method meshWave;\n}\n\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i=e.lambda;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      fvSolution;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nsolvers\n{\n    p\n    {\n        solver           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.p:o)?o.solver:o,n))?o:"")+";\n        tolerance        "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.p:o)?o.tolerance:o,n))?o:"")+";\n        relTol           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.p:o)?o.relTol:o,n))?o:"")+";\n        smoother         "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.p:o)?o.smoother:o,n))?o:"")+";\n    }\n\n    Phi\n    {\n        $p;\n    }\n\n    U\n    {\n        solver           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.U:o)?o.solver:o,n))?o:"")+";\n        smoother         "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.U:o)?o.smoother:o,n))?o:"")+";\n        tolerance        "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.U:o)?o.tolerance:o,n))?o:"")+";\n        relTol           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.U:o)?o.relTol:o,n))?o:"")+";\n        nSweeps          "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.U:o)?o.nSweeps:o,n))?o:"")+";\n    }\n\n    k\n    {\n        solver           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.k:o)?o.solver:o,n))?o:"")+";\n        smoother         "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.k:o)?o.smoother:o,n))?o:"")+";\n        tolerance        "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.k:o)?o.tolerance:o,n))?o:"")+";\n        relTol           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.k:o)?o.relTol:o,n))?o:"")+";\n        nSweeps          "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.k:o)?o.nSweeps:o,n))?o:"")+";\n    }\n\n    omega\n    {\n        solver           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.omega:o)?o.solver:o,n))?o:"")+";\n        smoother         "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.omega:o)?o.smoother:o,n))?o:"")+";\n        tolerance        "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.omega:o)?o.tolerance:o,n))?o:"")+";\n        relTol           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.omega:o)?o.relTol:o,n))?o:"")+";\n        nSweeps          "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.solvers:n)?o.omega:o)?o.nSweeps:o,n))?o:"")+";\n    }\n}\n\nSIMPLE\n{\n    nNonOrthogonalCorrectors  "+(null!=(o=i(null!=(o=null!=(o=null!=(o=null!=n?n.solvers:n)?o.correctors:o)?o.simple:o)?o.nNonOrthogonalCorrectors:o,n))?o:"")+";\n    consistent                "+(null!=(o=i(null!=(o=null!=(o=null!=(o=null!=n?n.solvers:n)?o.correctors:o)?o.simple:o)?o.consistent:o,n))?o:"")+";\n}\n\npotentialFlow\n{\n    nNonOrthogonalCorrectors  "+(null!=(o=i(null!=(o=null!=(o=null!=(o=null!=n?n.solvers:n)?o.correctors:o)?o.potentialFlow:o)?o.nNonOrthogonalCorrectors:o,n))?o:"")+";\n}\n\nrelaxationFactors\n{\n    equations\n    {\n        U               "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.relaxationFactors:n)?o.equations:o)?o.U:o,n))?o:"")+";\n        k               "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.relaxationFactors:n)?o.equations:o)?o.k:o,n))?o:"")+";\n        omega           "+(null!=(o=i(null!=(o=null!=(o=null!=n?n.relaxationFactors:n)?o.equations:o)?o.omega:o,n))?o:"")+";\n    }\n}\n\ncache\n{\n    grad(U);\n}\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o;return'/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      meshQualityDict;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n// Include defaults parameters from master dictionary\n#includeEtc "caseDicts/meshQualityDict"\n\n//- minFaceWeight (0 -> 0.5)\nminFaceWeight   '+(null!=(o=e.lambda(null!=(o=null!=n?n.meshQuality:n)?o.minFaceWeight:o,n))?o:"")+";\n\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({1:function(e,n,l,t,a){var o,i;return(null!=(i=null!=(i=l.step||(null!=n?n.step:n))?i:l.helperMissing,o="function"==typeof i?i.call(null!=n?n:{},{name:"step",hash:{},data:a}):i)?o:"")+" true;\n"},compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o,i,r=null!=n?n:{},s=e.lambda,u=l.helperMissing,d="function";return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      snappyHexMeshDict;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n// Which of the steps to run\n"+(null!=(o=l.each.call(r,null!=(o=null!=n?n.hexMesh:n)?o.steps:o,null!=n?n.as:n,null!=n?n.step:n,{name:"each",hash:{},fn:e.program(1,a,0),inverse:e.noop,data:a}))?o:"")+"\n// Geometry. Definition of all surfaces. All surfaces are of class\n// searchableSurface.\n// Surfaces are used\n// - to specify refinement for any mesh cell intersecting it\n// - to specify refinement for any mesh cell inside/outside/near\n// - to 'snap' the mesh boundary to the surface\ngeometry\n{\n    "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.name:o,n))?o:"")+".obj\n    {\n        type triSurfaceMesh;\n        name "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.name:o,n))?o:"")+";\n    }\n\n    refinementBox\n    {\n        type "+(null!=(o=s(null!=(o=null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.refinementBox:o)?o.type:o,n))?o:"")+";\n        min ("+(null!=(o=(l.vector||n&&n.vector||u).call(r,null!=(o=null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.refinementBox:o)?o.min:o,{name:"vector",hash:{},data:a}))?o:"")+");\n        max ("+(null!=(o=(l.vector||n&&n.vector||u).call(r,null!=(o=null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.refinementBox:o)?o.max:o,{name:"vector",hash:{},data:a}))?o:"")+");\n    }\n};\n\n\n\n// Settings for the castellatedMesh generation.\ncastellatedMeshControls\n{\n\n    // Refinement parameters\n    // ~~~~~~~~~~~~~~~~~~~~~\n\n    // If local number of cells is >= maxLocalCells on any processor\n    // switches from from refinement followed by balancing\n    // (current method) to (weighted) balancing before refinement.\n    maxLocalCells "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.maxLocalCells:o,n))?o:"")+";\n\n    // Overall cell limit (approximately). Refinement will stop immediately\n    // upon reaching this number so a refinement level might not complete.\n    // Note that this is the number of cells before removing the part which\n    // is not 'visible' from the keepPoint. The final number of cells might\n    // actually be a lot less.\n    maxGlobalCells "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.maxGlobalCells:o,n))?o:"")+";\n\n    // The surface refinement loop might spend lots of iterations refining just a\n    // few cells. This setting will cause refinement to stop if <= minimumRefine\n    // are selected for refinement. Note: it will at least do one iteration\n    // (unless the number of cells to refine is 0)\n    minRefinementCells "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.minRefinementCells:o,n))?o:"")+";\n\n    // Allow a certain level of imbalance during refining\n    // (since balancing is quite expensive)\n    // Expressed as fraction of perfect balance (= overall number of cells /\n    // nProcs). 0=balance always.\n    maxLoadUnbalance "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.maxLoadUnbalance:o,n))?o:"")+";\n\n\n    // Number of buffer layers between different levels.\n    // 1 means normal 2:1 refinement restriction, larger means slower\n    // refinement.\n    nCellsBetweenLevels "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.nCellsBetweenLevels:o,n))?o:"")+';\n\n\n\n    // Explicit feature edge refinement\n    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    // Specifies a level for any cell intersected by its edges.\n    // This is a featureEdgeMesh, read from constant/triSurface for now.\n    features\n    (\n        {\n            file "'+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.name:o,n))?o:"")+".eMesh\";\n            level 6;\n        }\n    );\n\n\n\n    // Surface based refinement\n    // ~~~~~~~~~~~~~~~~~~~~~~~~\n\n    // Specifies two levels for every surface. The first is the minimum level,\n    // every cell intersecting a surface gets refined up to the minimum level.\n    // The second level is the maximum level. Cells that 'see' multiple\n    // intersections where the intersections make an\n    // angle > resolveFeatureAngle get refined up to the maximum level.\n\n    refinementSurfaces\n    {\n        "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.name:o,n))?o:"")+"\n        {\n            // Surface-wise min and max refinement level\n            level (5 6);\n\n            // Optional specification of patch type (default is wall). No\n            // constraint types (cyclic, symmetry) etc. are allowed.\n            patchInfo\n            {\n                type wall;\n                inGroups ("+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:u,o=typeof i===d?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+");\n            }\n        }\n    }\n\n    // Resolve sharp angles\n    resolveFeatureAngle "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.resolveFeatureAngle:o,n))?o:"")+";\n\n\n    // Region-wise refinement\n    // ~~~~~~~~~~~~~~~~~~~~~~\n\n    // Specifies refinement level for cells in relation to a surface. One of\n    // three modes\n    // - distance. 'levels' specifies per distance to the surface the\n    //   wanted refinement level. The distances need to be specified in\n    //   descending order.\n    // - inside. 'levels' is only one entry and only the level is used. All\n    //   cells inside the surface get refined up to the level. The surface\n    //   needs to be closed for this to be possible.\n    // - outside. Same but cells outside.\n\n    refinementRegions\n    {\n        refinementBox\n        {\n            mode inside;\n            levels ((1E15 4));\n        }\n    }\n\n\n    // Mesh selection\n    // ~~~~~~~~~~~~~~\n\n    // After refinement patches get added for all refinementSurfaces and\n    // all cells intersecting the surfaces get put into these patches. The\n    // section reachable from the locationInMesh is kept.\n    // NOTE: This point should never be on a face, always inside a cell, even\n    // after refinement.\n    locationInMesh ("+(null!=(o=(l.vector||n&&n.vector||u).call(r,null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.locationInMesh:o,{name:"vector",hash:{},data:a}))?o:"")+");\n\n\n    // Whether any faceZones (as specified in the refinementSurfaces)\n    // are only on the boundary of corresponding cellZones or also allow\n    // free-standing zone faces. Not used if there are no faceZones.\n    allowFreeStandingZoneFaces "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.castellatedMeshControls:o)?o.allowFreeStandingZoneFaces:o,n))?o:"")+";\n}\n\n\n\n// Settings for the snapping.\nsnapControls\n{\n    //- Number of patch smoothing iterations before finding correspondence\n    //  to surface\n    nSmoothPatch "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.nSmoothPatch:o,n))?o:"")+";\n\n    //- Relative distance for points to be attracted by surface feature point\n    //  or edge. True distance is this factor times local\n    //  maximum edge length.\n    tolerance "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.tolerance:o,n))?o:"")+";\n\n    //- Number of mesh displacement relaxation iterations.\n    nSolveIter "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.nSolveIter:o,n))?o:"")+";\n\n    //- Maximum number of snapping relaxation iterations. Should stop\n    //  before upon reaching a correct mesh.\n    nRelaxIter "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.nRelaxIter:o,n))?o:"")+";\n\n    // Feature snapping\n\n        //- Number of feature edge snapping iterations.\n        //  Leave out altogether to disable.\n        nFeatureSnapIter "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.nFeatureSnapIter:o,n))?o:"")+";\n\n        //- Detect (geometric only) features by sampling the surface\n        //  (default=false).\n        implicitFeatureSnap "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.implicitFeatureSnap:o,n))?o:"")+";\n\n        //- Use castellatedMeshControls::features (default = true)\n        explicitFeatureSnap "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.explicitFeatureSnap:o,n))?o:"")+";\n\n        //- Detect points on multiple surfaces (only for explicitFeatureSnap)\n        multiRegionFeatureSnap "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.snapControls:o)?o.multiRegionFeatureSnap:o,n))?o:"")+";\n}\n\n\n\n// Settings for the layer addition.\naddLayersControls\n{\n    // Are the thickness parameters below relative to the undistorted\n    // size of the refined cell outside layer (true) or absolute sizes (false).\n    relativeSizes "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.relativeSizes:o,n))?o:"")+';\n\n    // Per final patch (so not geometry!) the layer information\n    layers\n    {\n        "(bottomWall|'+(null!=(i=null!=(i=l.meshGroupName||(null!=n?n.meshGroupName:n))?i:u,o=typeof i===d?i.call(r,{name:"meshGroupName",hash:{},data:a}):i)?o:"")+').*"\n        {\n            nSurfaceLayers 1;\n        }\n    }\n\n    // Expansion factor for layer mesh\n    expansionRatio '+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.expansionRatio:o,n))?o:"")+";\n\n    // Wanted thickness of final added cell layer. If multiple layers\n    // is the thickness of the layer furthest away from the wall.\n    // Relative to undistorted size of cell outside layer.\n    // See relativeSizes parameter.\n    finalLayerThickness "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.finalLayerThickness:o,n))?o:"")+";\n\n    // Minimum thickness of cell layer. If for any reason layer\n    // cannot be above minThickness do not add layer.\n    // Relative to undistorted size of cell outside layer.\n    minThickness "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.minThickness:o,n))?o:"")+";\n\n    // If points get not extruded do nGrow layers of connected faces that are\n    // also not grown. This helps convergence of the layer addition process\n    // close to features.\n    // Note: changed(corrected) w.r.t 17x! (didn't do anything in 17x)\n    nGrow "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nGrow:o,n))?o:"")+";\n\n    // Advanced settings\n\n    // When not to extrude surface. 0 is flat surface, 90 is when two faces\n    // are perpendicular\n    featureAngle "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.featureAngle:o,n))?o:"")+";\n\n    // At non-patched sides allow mesh to slip if extrusion direction makes\n    // angle larger than slipFeatureAngle.\n    slipFeatureAngle "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.slipFeatureAngle:o,n))?o:"")+";\n\n    // Maximum number of snapping relaxation iterations. Should stop\n    // before upon reaching a correct mesh.\n    nRelaxIter "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nRelaxIter:o,n))?o:"")+";\n\n    // Number of smoothing iterations of surface normals\n    nSmoothSurfaceNormals "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nSmoothSurfaceNormals:o,n))?o:"")+";\n\n    // Number of smoothing iterations of interior mesh movement direction\n    nSmoothNormals "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nSmoothNormals:o,n))?o:"")+";\n\n    // Smooth layer thickness over surface patches\n    nSmoothThickness "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nSmoothThickness:o,n))?o:"")+";\n\n    // Stop layer growth on highly warped cells\n    maxFaceThicknessRatio "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.maxFaceThicknessRatio:o,n))?o:"")+";\n\n    // Reduce layer growth where ratio thickness to medial\n    // distance is large\n    maxThicknessToMedialRatio "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.maxThicknessToMedialRatio:o,n))?o:"")+";\n\n    // Angle used to pick up medial axis points\n    // Note: changed(corrected) w.r.t 17x! 90 degrees corresponds to 130 in 17x.\n    minMedianAxisAngle "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.minMedianAxisAngle:o,n))?o:"")+";\n\n\n    // Create buffer region for new layer terminations\n    nBufferCellsNoExtrude "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nBufferCellsNoExtrude:o,n))?o:"")+";\n\n\n    // Overall max number of layer addition iterations. The mesher will exit\n    // if it reaches this number of iterations; possibly with an illegal\n    // mesh.\n    nLayerIter "+(null!=(o=s(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.addLayersControls:o)?o.nLayerIter:o,n))?o:"")+';\n}\n\n\n\n// Generic mesh quality settings. At any undoable phase these determine\n// where to undo.\nmeshQualityControls\n{\n    #include "meshQualityDict"\n\n\n    // Advanced\n\n    //- Number of error distribution iterations\n    nSmoothScale 4;\n    //- Amount to scale back displacement at error points\n    errorReduction 0.75;\n}\n\n\n// Advanced\n\n// Write flags\nwriteFlags\n(\n    scalarLevels\n    layerSets\n    layerFields     // write volScalarField for layer coverage\n);\n\n\n// Merge tolerance. Is fraction of overall bounding box of initial mesh.\n// Note: the write tolerance needs to be higher than this.\nmergeTolerance 1e-6;\n\n\n// ************************************************************************* //\n'},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o;return"/*--------------------------------*- C++ -*----------------------------------*\\\n| =========                 |                                                 |\n| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n|  \\\\    /   O peration     | Version:  4.1                                   |\n|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n|    \\\\/     M anipulation  |                                                 |\n\\*---------------------------------------------------------------------------*/\nFoamFile\n{\n    version     2.0;\n    format      ascii;\n    class       dictionary;\n    object      surfaceFeatureExtractDict;\n}\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n"+(null!=(o=e.lambda(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.name:o,n))?o:"")+".obj\n{\n    // How to obtain raw features (extractFromFile || extractFromSurface)\n    extractionMethod    extractFromSurface;\n\n    extractFromSurfaceCoeffs\n    {\n        // Mark edges whose adjacent surface normals are at an angle less\n        // than includedAngle as features\n        // - 0  : selects no edges\n        // - 180: selects all edges\n        includedAngle   150;\n    }\n\n    subsetFeatures\n    {\n        // Keep nonManifold edges (edges with >2 connected faces)\n        nonManifoldEdges       no;\n\n        // Keep open edges (edges with 1 connected face)\n        openEdges       yes;\n    }\n\n\n    // Write options\n\n        // Write features to obj format for postprocessing\n        writeObj                yes;\n}\n\n\n// ************************************************************************* //\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){return"#!/bin/sh\n\n# Source tutorial clean functions\n. $WM_PROJECT_DIR/bin/tools/CleanFunctions\n\n# remove surface and features\nrm -rf constant/extendedFeatureEdgeMesh > /dev/null 2>&1\nrm -f constant/triSurface/mesh.eMesh > /dev/null 2>&1\n\nrm -rf 0 > /dev/null 2>&1\n\ncleanCase\n"},useData:!0})},function(e,n,l){var t=l(11);e.exports=(t["default"]||t).template({compiler:[7,">= 4.0.0"],main:function(e,n,l,t,a){var o;return"#!/bin/sh\ncd ${0%/*} || exit 1    # Run from this directory\n\n# Source tutorial run functions\n. $WM_PROJECT_DIR/bin/tools/RunFunctions\n\n# copy mesh surface from root directory\nmkdir -p ./constant/triSurface\ncp "+(null!=(o=e.lambda(null!=(o=null!=(o=null!=n?n.hexMesh:n)?o.geometry:o)?o.name:o,n))?o:"")+".obj ./constant/triSurface/\n\nrunApplication surfaceFeatureExtract\n\nrunApplication blockMesh\n\nrunApplication decomposePar\nrunParallel snappyHexMesh -overwrite\n\n#- For non-parallel running\n#cp -r 0.orig 0 > /dev/null 2>&1\n\n#- For parallel running\nls -d processor* | xargs -I {} rm -rf ./{}/0\nls -d processor* | xargs -I {} cp -r 0.orig ./{}/0\n\nrunParallel patchSummary\nrunParallel potentialFoam\nrunParallel $(getApplication)\n\nrunApplication reconstructParMesh -constant\nrunApplication reconstructPar -latestTime\n\n#------------------------------------------------------------------------------\n"},useData:!0})}]);